// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

RWStructuredBuffer<float4> Result;
RWStructuredBuffer<float4> OriginalPosition;

float3 position; // The position of the moving point

float inverseLerp(float min, float max, float value)
{
    // Return 0 if min equals max to avoid division by zero
    if (min == max)
        return 0.0;
    
    // Clamp the output to the 0-1 range
    return saturate((value - min) / (max - min));
}

[numthreads(128, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    float4 basePosition = Result[id.x];
    float4 originalPosition = OriginalPosition[id.x];
    
    //Distance
    float dist = distance(basePosition.xyz, position);
    
    //Remapping 
    // 4 good
    float t = smoothstep(20.0f, 0, dist); // What is this
    
    //Push amount
    float3 dir = normalize(basePosition.xyz - position);
    //0.5 good
    float3 pushAmount = dir * lerp(0, 10.0f, t); // What does this lerp work speed of the movement
    float3 newPosition = basePosition.xyz + pushAmount;
    
    //Pull
    
    // ============ For faster pull ============
    float convertDistanceFromSphereToBox = inverseLerp(100.0f, 150.0f, dist); //Indicated at what distance start pulling
    newPosition = lerp(newPosition, originalPosition.xyz, convertDistanceFromSphereToBox);
    //=========================================
    
    //============ For slower pull ============
    //float newDist = distance(newPosition, originalPosition.xyz);
    //float remap = smoothstep(0, 20.0f, dist);
    //float3 dirToOriginal = normalize(originalPosition.xyz - newPosition);
    //float3 pullAmount = dirToOriginal * lerp(0, 0.1f, remap);
    //pullAmount = (newDist > 0.1f) ? pullAmount : float3(0, 0, 0);
    //newPosition = newPosition + pullAmount;
    //=========================================
    

    Result[id.x] = float4(newPosition, 1);
    
}

