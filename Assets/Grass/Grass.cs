using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

public class Grass : MonoBehaviour
{
    [SerializeField] private Mesh instanceMesh;
    [SerializeField] private Material instanceMaterial;
    [SerializeField] private int instanceCount = 500000;
    [SerializeField] private ComputeShader computeShader;

    // CHUINKING
    // Max instances per chunk to avoid too many dispatches that can lead to ->
    // -> GPU dispatch limit
    // -> GPU memory limit
    // -> Driver timeout
    // -> Thread group scheduler limit
    [SerializeField] private int maxChunkSize = 65536; 
    // If we want to update the chunks then we can do it over multiple frames
    [SerializeField] private int framesPerChunk = 1;

    private int kernel;
    private ComputeBuffer argsBuffer;
    private const int ARGS_STRIDE = sizeof(uint) * 5;
    private ComputeBuffer transformBuffer; // Stores Matrix4x4 for each instance manipulated by compute shader
    private const int TRANSFORM_STRIDE = sizeof(float) * 16;
    private ComputeBuffer noiseBuffer; // Stores perlin noise value generated by compute shader for grass length
    private const int NOISE_STRIDE = sizeof(float);

    // Chunking variables
    private int currentChunkIndex = 0;
    private List<ChunkData> chunks = new List<ChunkData>();
    private int frameCounter = 0;

    [SerializeField] private Material testMat; // Used this material to test how is perlin noise flowing

    // Chunk data that will be passed to the dispatch call
    [System.Serializable]
    public struct ChunkData
    {
        public int startIndex; // Helps to set offset in the buffer for each chunk so that we can use it to access appropriate element
        public int count; // Total number of instances in the chunk. Used to early exit in Compute shader to avoid crashes
        public int dispatchX; // Define thread group size
        public int dispatchY; // Define thread group size
        public int dispatchZ; // Define thread group size
    }

    private void OnEnable()
    {
        argsBuffer = new ComputeBuffer(1, ARGS_STRIDE, ComputeBufferType.IndirectArguments);
        argsBuffer.SetData(new uint[] { 0, 1, 0, 0, 0 });

        transformBuffer = new ComputeBuffer(instanceCount, TRANSFORM_STRIDE);
        noiseBuffer = new ComputeBuffer(instanceCount, NOISE_STRIDE);

        kernel = computeShader.FindKernel("CSMain");
        if (kernel < 0)
        {
            Debug.LogError("Could not find kernel 'CSMain' in compute shader!");
            return;
        }

        SetupChunks();
    }

    // Creates multiple chunks that we can dispatch with relevant data
    private void SetupChunks()
    {
        chunks.Clear();
        // Multiple chunks
        for (int i = 0; i < instanceCount; i += maxChunkSize)
        {
            // Last chunk might be smaller than maxChunkSize 
            int chunkCount = Mathf.Min(maxChunkSize, instanceCount - i);
            chunks.Add(new ChunkData
            {
                startIndex = i,
                count = chunkCount,
                dispatchX = CalculateDispatchX(chunkCount),
                dispatchY = CalculateDispatchY(chunkCount),
                dispatchZ = 1
            });
        }

        Debug.Log($"Created {chunks.Count} chunks for {instanceCount} instances");
    }

    private void OnDisable()
    {
        argsBuffer?.Release();
        argsBuffer = null;
        transformBuffer?.Release();
        transformBuffer = null;
        noiseBuffer?.Release();
        noiseBuffer = null;
    }

    private void Start()
    {
        // Initialize buffers
        InitializeBuffers();

        // Process all chunks at once (for immediate update)
        ProcessAllChunks();
    }

    // Populates the buffers and sets them to compute shader and the material
    private void InitializeBuffers()
    {
        uint[] args = { 0, 1, 0, 0, 0 };
        args[0] = (uint)instanceMesh.GetIndexCount(0);
        args[1] = (uint)instanceCount;
        args[2] = instanceMesh.GetIndexStart(0);
        args[3] = instanceMesh.GetBaseVertex(0);
        args[4] = 0;
        argsBuffer.SetData(args);

        // Initialize transform buffer with identity matrices
        Matrix4x4[] transforms = new Matrix4x4[instanceCount];
        float[] noise = new float[instanceCount];

        for (int i = 0; i < instanceCount; i++)
        {
            transforms[i] = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Vector3.one);
            noise[i] = 0.0f;
        }

        transformBuffer.SetData(transforms);
        noiseBuffer.SetData(noise);

        // Set buffers to compute shader
        computeShader.SetBuffer(kernel, "Result", transformBuffer);
        computeShader.SetBuffer(kernel, "noise", noiseBuffer);

        // Set buffers to material
        instanceMaterial.SetBuffer("transform", transformBuffer);
        instanceMaterial.SetBuffer("noise", noiseBuffer);
    }

    // Calls ProcessChunks in a for loop
    private void ProcessAllChunks()
    {
        for (int i = 0; i < chunks.Count; i++)
        {
            ProcessChunk(i);
        }
    }

    // Sets compute shader parameters from chunk data struct and dispatches it
    // Each dispatch should populate the compute shader with different values
    private void ProcessChunk(int chunkIndex)
    {
        if (chunkIndex >= chunks.Count) return;

        ChunkData chunk = chunks[chunkIndex];

        // Set compute shader parameters for this chunk
        computeShader.SetInt("count", chunk.count);
        computeShader.SetInt("chunkOffset", chunk.startIndex);
        computeShader.SetInt("totalCount", instanceCount);
        computeShader.SetFloat("dispatchX", chunk.dispatchX);
        computeShader.SetFloat("dispatchY", chunk.dispatchY);

        // Dispatch the chunk
        computeShader.Dispatch(kernel, chunk.dispatchX, chunk.dispatchY, chunk.dispatchZ);
    }

    private void Update()
    {
        // Update chunks over multiple frames if enabled
        // Only needed if we want to update the chunks if we have something that is changing evenry frame and GPU should know about it
        if (framesPerChunk > 1)
        {
            Debug.Log($"Processing chunk {currentChunkIndex} of {chunks.Count}");
            UpdateChunkedBuffer();
        }

        // GPU Instancing
        Graphics.DrawMeshInstancedIndirect(instanceMesh, 0, instanceMaterial,
            new Bounds(Vector3.zero, Vector3.one * 1000), argsBuffer);
    }

    // Update chunks over multiple frames as frame counter is increased every frame and when it reaches framesPerChunk we process the chunk
    private void UpdateChunkedBuffer()
    {
        frameCounter++;

        if (frameCounter >= framesPerChunk)
        {
            // So that we can keep processing chunks over multiple frames
            frameCounter = 0;

            if (chunks.Count > 0)
            {
                ProcessChunk(currentChunkIndex);
                // Move to next chunk but when we reach the end of the list we start from the beginning
                // This is possible because of the % operator
                // For example if we have 3 chunks and currentChunkIndex is 2 then (2 + 1) % 3 = 0
                currentChunkIndex = (currentChunkIndex + 1) % chunks.Count;
            }
        }
    }
    private int CalculateDispatchX(int count)
    {
        // Computer shader uses [numthreads(8, 8, 1)] and calculates positions in a grid
        // As we want a square grid we just square root the total count so that we get how many instance we need per axis
        // This is also needed as we are dispatching a 2D grid
        int perAxis = Mathf.CeilToInt(Mathf.Sqrt(count));
        // Example ->
        // Count = 256 || This means we have 16 instances per axis
        // This means we need 2 thread groups per axis (16 / 8 = 2)
        // Each thread group will have 8 threads in each axis makinga total of 8 * 2 = 16 threads per axis means 256 instances in total
        return Mathf.CeilToInt(perAxis / 8.0f);
    }
    private int CalculateDispatchY(int count)
    {
        // Same as above
        int perAxis = Mathf.CeilToInt(Mathf.Sqrt(count));
        return Mathf.CeilToInt(perAxis / 8.0f);
    }

}